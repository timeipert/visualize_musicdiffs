<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body { font-family: sans-serif; }
        #network, #axis { border: 1px solid #ccc; margin: 10px 0; }
        #beatLabel { margin-left: 10px; }
        .tooltip {
            position: absolute;
            pointer-events: none;
            background: rgba(255,255,255,0.9);
            border: 1px solid #999;
            padding: 6px;
            font-size: 12px;
            border-radius: 4px;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.3);
            max-width: 300px;
            white-space: pre-wrap;
        }
        .legend text {
            font-size: 12px;
            alignment-baseline: middle;
        }
    </style>
</head>
<body>

<input type="file" id="diffFiles" multiple accept=".txt" />
<button id="loadBtn">Load</button>
<br /><br />
<svg id="network" width="1200" height="400"></svg>
<p><small>Click on the axis to enable selection</small></p>
<svg id="axis" width="1200" height="1000"></svg>
<br />
<input type="range" id="beatSlider" min="0" max="1" step="1" disabled />
<span id="beatLabel">Measure: –, Beat: –</span>

<div id="tooltip" class="tooltip" style="display: none;"></div>

<script>
    const fileInput = document.getElementById("diffFiles"),
        loadBtn    = document.getElementById("loadBtn"),
        beatSlider = document.getElementById("beatSlider"),
        beatLabel  = document.getElementById("beatLabel"),
        netSvg     = d3.select("#network"),
        axSvg      = d3.select("#axis"),
        tooltip    = d3.select("#tooltip"),
        width      = +netSvg.attr("width"),
        height     = +netSvg.attr("height"),
        axHeight   = +axSvg.attr("height"),
        netG       = netSvg.append("g"),
        linkG      = netG.append("g"),
        nodeG      = netG.append("g"),

        // During parsing, store only those beats that appeared in diffs
        diffByBeat = {},          // global count, keyed by "M-B"
        beatInfo   = {},          // maps "M-B" → { measure: M, beat: B }
        edges      = [],
        nodesMap   = {};

    function parseDiff(text, filename) {
        const lines = text.split("\n");
        const a = lines[0].replace(/--- (\/.*)\//, ""),
            b = lines[1].replace(/\+\+\+ (\/.*)\//, "");
        if (!nodesMap[a]) nodesMap[a] = { id: a };
        if (!nodesMap[b]) nodesMap[b] = { id: b };

        const edge = { source: a, target: b, beatCounts: {}, beatDetails: {} };
        let curKeyStr = null;

        lines.forEach(line => {
            if (line.startsWith("@@")) {
                const m = /measure\s+(\d+),.*beat\s+([\d.]+)/.exec(line);
                if (m) {
                    const M = parseInt(m[1], 10),
                        B = parseFloat(m[2]),
                        keyStr = `${M}-${B}`;
                    curKeyStr = keyStr;
                    if (!beatInfo[keyStr]) {
                        beatInfo[keyStr] = { measure: M, beat: B };
                        diffByBeat[keyStr] = 0;
                    }
                }
            } else if (curKeyStr !== null && (line.startsWith("+") || line.startsWith("-"))) {
                edge.beatCounts[curKeyStr] = (edge.beatCounts[curKeyStr] || 0) + 1;
                diffByBeat[curKeyStr] = (diffByBeat[curKeyStr] || 0) + 1;
                if (!edge.beatDetails[curKeyStr]) edge.beatDetails[curKeyStr] = [];
                edge.beatDetails[curKeyStr].push(line);
            }
        });

        edges.push(edge);
    }

    loadBtn.onclick = () => {
        const files = fileInput.files;
        if (!files.length) return;
        let loaded = 0;
        for (let f of files) {
            const reader = new FileReader();
            reader.onload = () => {
                parseDiff(reader.result, f.name);
                if (++loaded === files.length) initVis();
            };
            reader.readAsText(f);
        }
    };

    function initVis() {
        //
        // ─── 1) FILL MISSING “M-B” BEATS WITH ZERO ENTRIES ───────────────────
        //
        const beatsByMeasure = {};
        Object.entries(beatInfo).forEach(([keyStr, info]) => {
            const M = info.measure,
                B = info.beat;
            if (!beatsByMeasure[M]) beatsByMeasure[M] = new Set();
            beatsByMeasure[M].add(B);
        });

        Object.entries(beatsByMeasure).forEach(([mStr, beatSet]) => {
            const M = parseInt(mStr, 10);
            let beatsArr = Array.from(beatSet).sort((a, b) => a - b);

            let step = 1.0;
            if (beatsArr.length > 1) {
                const diffs = [];
                for (let i = 1; i < beatsArr.length; i++) {
                    diffs.push(beatsArr[i] - beatsArr[i - 1]);
                }
                step = Math.min(...diffs);
            }

            const minB = beatsArr[0],
                maxB = beatsArr[beatsArr.length - 1],
                nSteps = Math.round((maxB - minB) / step);

            for (let i = 0; i <= nSteps; i++) {
                const Bcur = +((minB + i * step).toFixed(6));
                const keyStr = `${M}-${Bcur}`;
                if (!beatInfo[keyStr]) {
                    beatInfo[keyStr] = { measure: M, beat: Bcur };
                    diffByBeat[keyStr] = 0;
                    edges.forEach(e => {
                        e.beatCounts[keyStr] = 0;
                        e.beatDetails[keyStr] = [];
                    });
                }
            }
        });


        //
        // ─── 2) SORT “M-B” KEYS AND ASSIGN INTEGER INDICES ───────────────────
        //
        const allBeatKeys = Object.keys(beatInfo).slice();
        allBeatKeys.sort((a, b) => {
            const [mA, bA] = a.split("-").map(Number);
            const [mB, bB] = b.split("-").map(Number);
            if (mA !== mB) return mA - mB;
            return bA - bB;
        });

        const beatIndex = {};
        allBeatKeys.forEach((keyStr, i) => {
            beatIndex[keyStr] = i;
        });

        // Re‐map diffByBeat → numeric keys
        const numericDiffByBeat = {};
        allBeatKeys.forEach(keyStr => {
            const idx = beatIndex[keyStr];
            numericDiffByBeat[idx] = diffByBeat[keyStr] || 0;
        });

        // Re‐map each edge’s beatCounts/beatDetails → integer keys
        const linkData = edges.map(e => {
            const newCounts = {},
                newDetails = {};
            Object.entries(e.beatCounts).forEach(([keyStr, count]) => {
                const idx = beatIndex[keyStr];
                newCounts[idx] = count;
                newDetails[idx] = e.beatDetails[keyStr] || [];
            });
            return {
                id: `${e.source}__${e.target}`,
                source: e.source,
                target: e.target,
                beatCounts: newCounts,
                beatDetails: newDetails
            };
        });


        //
        // ─── 3) COMPUTE A SINGLE GLOBAL MAXIMUM DIFF COUNT ───────────────────
        //
        // Look across all edges and all integer-beat keys:
        const globalMax = d3.max(
            linkData.map(d => d3.max(Object.values(d.beatCounts).length
                ? Object.values(d.beatCounts)
                : [0]))
        ) || 0;


        //
        // ─── 4) DRAW NETWORK + LEGEND ───────────────────
        //
        const nodes = Object.values(nodesMap);
        const color = d3.scaleOrdinal(d3.schemeCategory10)
            .domain(linkData.map(d => d.id));

        const legend = netSvg.append("g")
            .attr("class", "legend")
            .attr("transform", `translate(${width - 320}, 20)`);

        legend.selectAll("g.entry")
            .data(linkData)
            .enter()
            .append("g")
            .attr("class", "entry")
            .attr("transform", (d, i) => `translate(0, ${i * 20})`)
            .each(function(d) {
                d3.select(this)
                    .append("rect")
                    .attr("x", 0)
                    .attr("y", -10)
                    .attr("width", 12)
                    .attr("height", 12)
                    .attr("fill", color(d.id));
                d3.select(this)
                    .append("text")
                    .attr("x", 18)
                    .attr("y", 0)
                    .text(`${d.source} ↔ ${d.target}`);
            });


        //
        // ─── 5) DRAW BAR PANELS (ONE PER EDGE) ───────────────────
        //
        const minKey = 0,
            maxKey = allBeatKeys.length - 1,
            nEdges  = linkData.length,
            panelHeight = axHeight / nEdges,
            barWidth = 4,
            marginLeft = 40;

        // X scale: 0 → (Nbeats−1)
        const xScale = d3.scaleLinear()
            .domain([minKey, maxKey])
            .range([marginLeft, width - 40]);

        linkData.forEach((d, i) => {
            // Instead of computing a per-edge max, we use globalMax everywhere:
            const yScale = d3.scaleLinear()
                .domain([0, globalMax || 1])     // <— same domain for every panel
                .range([panelHeight, 0]);

            const panelGroup = axSvg.append("g")
                .attr("transform", `translate(0, ${i * panelHeight})`);

            // (a) Draw baseline
            panelGroup.append("line")
                .attr("x1", xScale(minKey))
                .attr("y1", panelHeight)
                .attr("x2", xScale(maxKey))
                .attr("y2", panelHeight)
                .attr("stroke", "#000");

            // (b) Draw every beat's bar (zero-height if count=0)
            for (let keyNum = minKey; keyNum <= maxKey; keyNum++) {
                const c = d.beatCounts[keyNum] || 0;
                const x = xScale(keyNum) - barWidth / 2;
                const y = yScale(c),
                    h = panelHeight - y;
                panelGroup.append("rect")
                    .attr("x", x)
                    .attr("y", y)
                    .attr("width", barWidth)
                    .attr("height", h)
                    .attr("fill", color(d.id));
            }

            // (c) Draw left‐axis; since all panels share the same domain, they’ll all have identical tick‐marks
            const yAxis = d3.axisLeft(yScale).ticks(3);
            panelGroup.append("g")
                .attr("transform", `translate(${marginLeft}, 0)`)
                .call(yAxis);

            // (d) (optional) Add panel label on the left
            /*panelGroup.append("text")
                .attr("x", marginLeft - 5)
                .attr("y", panelHeight / 2)
                .attr("text-anchor", "end")
                .attr("alignment-baseline", "middle")
                .attr("font-size", "12px")
                .text(`${d.source} ↔ ${d.target}`);*/
        });


        //
        // ─── 6) SINGLE VERTICAL “CURRENT BEAT” LINE ───────────────────
        //
        const indicator = axSvg.append("line")
            .attr("x1", xScale(minKey))
            .attr("x2", xScale(minKey))
            .attr("y1", 0)
            .attr("y2", axHeight)
            .attr("stroke", "blue")
            .attr("opacity", "0.5")
            .attr("stroke-width", 2);


        let isSelection = false;
        axSvg.on("click", (event) => {
            isSelection = !isSelection;
        });
        axSvg.on("mousemove", (event) => {
            if(!isSelection) return
            const [mx] = d3.pointer(event);
            let val = xScale.invert(mx);
            const nearest = Math.max(minKey, Math.min(maxKey, Math.round(val)));
            setCurrentBeat(nearest);
        });


        //
        // ─── 7) FORCE‐DIRECTED NETWORK LAYOUT ───────────────────
        //
        const simulation = d3.forceSimulation(nodes)
            .force("link", d3.forceLink(linkData).id(d => d.id).distance(150))
            .force("charge", d3.forceManyBody().strength(-200))
            .force("center", d3.forceCenter(width / 2, height / 2));

        const linkGroups = linkG.selectAll("g.linkGroup")
            .data(linkData)
            .enter()
            .append("g")
            .attr("class", "linkGroup");

        linkGroups.append("line")
            .attr("class", "hitarea")
            .attr("stroke", "transparent")
            .attr("stroke-width", 10);

        linkGroups.append("line")
            .attr("class", "linkLine")
            .attr("stroke", d => color(d.id))
            .attr("stroke-width", 1);

        linkGroups.on("mouseover", (event, d) => {
            const currIdx = +beatSlider.value;
            const keyStr = allBeatKeys[currIdx];
            const info   = beatInfo[keyStr];
            const diffs  = d.beatDetails[currIdx] || [];
            let content  = `Edge ${d.source} ↔ ${d.target}\n`;
            content += `Measure ${info.measure}, Beat ${info.beat.toFixed(2)} diffs:\n`;
            if (diffs.length) {
                diffs.forEach(line => { content += line + "\n"; });
            } else {
                content += "(no diffs at this beat)\n";
            }
            tooltip.html(content)
                .style("left", (event.pageX + 10) + "px")
                .style("top", (event.pageY + 10) + "px")
                .style("display", "block");
        })
            .on("mousemove", (event) => {
                tooltip.style("left", (event.pageX + 10) + "px")
                    .style("top", (event.pageY + 10) + "px");
            })
            .on("mouseout", () => {
                tooltip.style("display", "none");
            });

        const node = nodeG.selectAll("circle")
            .data(nodes)
            .enter()
            .append("circle")
            .attr("r", 8)
            .attr("fill", "orange")
            .call(drag(simulation));

        const label = nodeG.selectAll("text")
            .data(nodes)
            .enter()
            .append("text")
            .text(d => d.id)
            .attr("font-size", 12)
            .attr("dx", 12)
            .attr("dy", 4);

        simulation.on("tick", () => {
            linkGroups.selectAll(".hitarea")
                .attr("x1", d => d.source.x)
                .attr("y1", d => d.source.y)
                .attr("x2", d => d.target.x)
                .attr("y2", d => d.target.y);

            linkGroups.selectAll(".linkLine")
                .attr("x1", d => d.source.x)
                .attr("y1", d => d.source.y)
                .attr("x2", d => d.target.x)
                .attr("y2", d => d.target.y)
                .attr("stroke-width", d => {
                    const currIdx = +beatSlider.value;
                    return d.beatCounts[currIdx] || 0;
                });

            node.attr("cx", d => d.x)
                .attr("cy", d => d.y);
            label.attr("x", d => d.x)
                .attr("y", d => d.y);
        });


        //
        // ─── 8) SLIDER SETUP ───────────────────
        //
        beatSlider.min = minKey;
        beatSlider.max = maxKey;
        beatSlider.step = 1;
        beatSlider.value = minKey;
        beatSlider.disabled = false;
        beatSlider.oninput = () => {
            const v = +beatSlider.value;
            setCurrentBeat(v);
        };

        setCurrentBeat(minKey);

        function setCurrentBeat(idx) {
            beatSlider.value = idx;
            const keyStr = allBeatKeys[idx];
            const info   = beatInfo[keyStr];
            beatLabel.textContent = `Measure: ${info.measure}, Beat: ${info.beat.toFixed(2)}`;
            indicator
                .attr("x1", xScale(idx))
                .attr("x2", xScale(idx));
            simulation.alpha(0.1).restart();
        }

        function drag(sim) {
            return d3.drag()
                .on("start", event => {
                    if (!event.active) sim.alphaTarget(0.3).restart();
                    event.subject.fx = event.subject.x;
                    event.subject.fy = event.subject.y;
                })
                .on("drag", event => {
                    event.subject.fx = event.x;
                    event.subject.fy = event.y;
                })
                .on("end", event => {
                    if (!event.active) sim.alphaTarget(0);
                    event.subject.fx = null;
                    event.subject.fy = null;
                });
        }
    }
</script>
</body>
</html>
